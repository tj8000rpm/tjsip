package main

import (
	"net/http"
	"sip/sip"
)

var (
	ErrRegistrationUnauthorized     = &sip.ProtocolError{"Unauthorized"}
	ErrRegistrationForbidden        = &sip.ProtocolError{"Not allowed"}
	ErrRegistrationNotFound         = &sip.ProtocolError{"Not Found"}
	ErrRegistrationIntervalTooBrief = &sip.ProtocolError{"Interval Too brief"}
)

const (
	REGISTRATION_QUERY = iota
	REGISTRATION_UPDATE
	REGISTRATION_ADD
	REGISTRATION_DEL
	REGISTRATION_DELALL
)

type RegistrationResult struct {
	Status  int
	Contact *sip.ContactHeaders
	Header  http.Header
}

func NewRegistrationResult(status int) *RegistrationResult {
	r := new(RegistrationResult)
	r.Status = status
	return r
}

type RegistrationOperation struct {
	Operation int
	Aor       *sip.URI
	BindAddr  *sip.URI
	Expires   int
}

func NewRegistrationOperation() *RegistrationOperation {
	r = new(RegistrationOperation)
	return r
}

func registration(msg *sip.Message) *RegistrationResult {
	origContacts := msg.Contact
	var origToAOR, origFromAOR *sip.URI
	if msg.To != nil && msg.To.Addr != nil {
		origToAOR = msg.To.Addr.Uri
	}
	if msg.From != nil && msg.From.Addr != nil {
		origFromAOR = msg.From.Addr.Uri
	}
	origExpires, err := strconv.Atoi(msg.Header.Get("Expires"))
	if err != nil {
		return NewRegistrationResult(sip.StatusBadRequest)
	}
	origCallID := msg.CallID
	origCSeq := msg.CSeq

	_ = origContacts
	_ = origToAOR
	_ = origFromAOR
	_ = origExpires
	_ = origCallID
	_ = origCSeq

	operations := make([]RegistrationOperation, len(contacts)+1)

	for idx, contact := range origContacts.Header {
			r[idx] = NewRegistrationOperation()
		if contact.Star {
			if origExpires != 0 {
				return NewRegistrationResult(sip.StatusBadRequest)
			}
			r[idx].Operation = REGISTRATION_DELALL
		}
	}
	r := NewRegistrationOperation()
	r.Operation = REGISTRATION_QUERY
	operations[len(operations)-1] = r

	return nil
}
